; This is a sample code of rk16 assembly language

@0x0200 hoge
@0x0123 fuga
@0x4567 piyo
@0x89AB foo
@0xcdef bar
@0x0010 exit

@0123 hoge

#0x0100 const
#0x0030 '0'
#0x0031 '1'
#0x0032 '2'
#0x0033 '3'
#0x0034 '4'
#0x0035 '5'

calc_test:
    nop           ; no operation
    mov  ss0 s1    ; s0 = s1
    add  t2 t0 t1 ; t2 = t0 + t1
    sub  t2 t0 t1 ; t2 = t0 - t1
    and  t2 t0 t1 ; t2 = t0 & t1
    or   t2 t0 t1 ; t2 = t0 | t1
    xor  t2 t0 t1 ; t2 = t0 ^ t1
    not  t2 t0    ; t2 = ~ t0
    srs  t2 t0    ; t2 = s>> t0
    sru  t2 t0    ; t2 = 0>> t0
    sl   t2 t0    ; t2 = t0 <<0
    eq   t2 t0 t1 ; t2 = t0 == t1
    ltu  t2 t0 t1 ; t2 = t0 < t1
    lts  t2 t0 t1 ; t2 = t0 < t1
calci_test:
    loadi t0    0x0123 ; t0 = 0x0123
    addi  t2 t0 const  ; t2 = t0 + const
    subi  t2 t0 hoge   ; t2 = t0 + hoge
    andi  t2 t0 fuga   ; t2 = t0 + fuga
    ori   t2 t0 0x0000
    xori  t2 t0 0x0110
    eqi   t2 t0 0x1100
    ltsi  t2 t0 0xf000
    ltui  t2 t0 0xf000
memory_test:
    load  t2 t0 hoge ; t2 <= [t0 + hoge]
    store t2 t0 fuga ; t2 => [t0 + fuga]
ctrl_test:
a:
    jump   e    ; pc = e
    jumpr  0x1  ; pc = pc + 0x1
    if  zero b  ; if zero = 0 ? pc = b
    ifr zero b  ; if zero = 0 ? pc = pc + b
b:
    call c ; pc = c, ra = pc + 1
c:
    ret  ; pc = ra
d:
    iret ; pc = ira
