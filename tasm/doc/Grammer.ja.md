# 文法

## 定義

プログラムは定義の集合です

|            | 記法                                               |
| ---------- | -------------------------------------------------- |
| 型         | `type hoge = {x : int, y : int};`                  |
| 定数       | `const hoge @ 0x0000 = 123;`                       |
| 変数       | `static hoge : int @ 0x0000;`                      |
| アセンブリ | `asm hoge @ 0x0000 { t0 = a; }`                    |
| 関数       | `fn hoge(a : int, b : int) -> int { return a+b; }` |

```
def  =
 | type   = 'type' ident '=' type ';'
 | const  = 'const' ident ?('@' expr) '=' expr ';'
 | static = 'static' ident ?('@' expr) ':' type ';'
 | asm    = 'asm' ident ?('(' args ')') ?('@' expr) '{' asm_stmt* '}'
 | func   = 'fn' ident '(' args ')' ?('->' type) stmt
```

### 型定義

独自の型は `type` 文で定義します。

`type hoge = {x : int, y : int};`

### 定数定義

定数は `const` 文で定義します。型は初期値から推論されます。

`const hoge = 123;`

オプションで `@` を使ってアドレスを指定できます。

`const hoge @ 0x0000 = 123;`

### グローバル変数定義

### アセンブリ定義

アセンブリシーケンスを定義するブロックです。

### 関数定義

## 型

|            | 記法                   |
| ---------- | ---------------------- |
| データ型   | `int`                  |
| アドレス型 | `*int`                 |
| 配列型     | `[N]int`               |
| 構造体型   | `{m0 : int, m1 : int}` |
| 関数型     | `(arg : int) -> int`   |

```
type =
 | data   = 'int'
 | addr   = '*' type
 | prim   = ident | '(' type ')'
 | arr    = '[' expr ']' type
 | struct = '{' (ident ':' type) % ',' '}'
 | func   = '(' (ident ':' type) % ',' ')' '->' type
```

### データ型

`int` - 16 ビット整数を表します。符号付きか符号無しかは、ハードウェアの実装に委ねられています。

### ポインタ型

`\*T` - 型 T の値へのポインタを表します。これは、16 ビットのメモリアドレスであり、T 型のデータが格納された別のメモリ領域を参照します。

### 配列型

`[N]T` - 型 T の要素が N 個連続して割り当てられた静的配列です。配列のサイズはコンパイル時に既知でなければならず、動的なサイズ変更はサポートされません。

### 構造体型

`{field1: T1, field2: T2}` - 複数の名前付きフィールドをまとめた合成データ型です。構造体は宣言された順に各メンバが連結された形でメモリ上に配置されます。

### 関数型

`(arg1: T1, arg2: T2) -> Ret` - 明示的な型を持つ固定数の引数を受け取り、Ret 型の値を返す関数を表します。

### 型のサイズ

tasm は Data = 16 bit / Addres = 16 bit のシステム向けに設計されています。この値は定数で指定されています。

型のサイズは固定です。次の計算規則に従い、コンパイル時に計算されます。

```
<int> = 1
<*T> = 1
<[N]T> = N × <T>
<{f₁: T₁, f₂: T₂, ...}> = <T₁> + <T₂> + ...
<(args) -> Ret> = 0
```

これらの規則により、型のサイズは常にコンパイル時に計算可能です。sizeof 演算子 `<>` は型が使用するメモリを 16bit 単位で返します。


### 参照演算子・アドレス演算子

`a*` で `a` をポインタとみなして、`a` の指す値を得ます。(後置演算子)

`a : *int` → `a* : int`

`a@` で `a` のアドレスを得ます。(後置演算子)

`a : int` → `a@ : *int`

### キャスト演算子

現在のパーサー実装では、キャスト演算子は構文の曖昧性を避けるため無効化されています。

将来的には、式の後にコロンと型を書いてキャストを行う構文が検討されています。

`expr : Type`

### 整数型

16bit 整数。
符号付きか無しかについては未定。
ハードウェアとかの都合で決める。

### ポインタ型

ポインタ型は 16bit のアドレスです。
これはアドレス空間が 16bit であることに由来します。

デリファレンス演算子を適用すると、ベース型になります。

`hoge : *int` → `hoge* : int`

アドレス演算子を適用すると、ポインタ型になります。

`hoge : int` → `hoge@ : *int`

### 配列型

配列はコンパイル時にベース型の N 個分のメモリを確保します。

添字演算子を適用すると、ベースの型になります。

`hoge : [N]int` → `hoge[0] : int`

多次元配列は、このように表されます。

`hoge : [N][M]int`

C 言語と異なり、配列とポインタの暗黙のキャストは行いません。

配列のアドレスが欲しい場合は、アドレス演算子を使います。

`hoge : [N]int` → `hoge@ : *[N]int`

配列の先頭の要素のアドレスは、このように取得します。

`hoge : [N]int` → `hoge[0]@ : *int`

これらのポインタの値は一致しますが、型は異なります。

### 構造体型

構造体のサイズはメンバの合計です。

メンバ演算子を適用すると、メンバの型になります。

`hoge : {a : int}` → `hoge.a : int`

### 関数型

関数型は関数の持つ型です。

関数呼び出し演算子を適用すると、返り値の型になります。

`hoge : (arg : Arg) -> Ret` → `hoge(arg) : Ret`

関数型の変数は定義できません。かわりに関数ポインタ型を使います。

`var hoge_p : *(arg : Arg) -> Ret = hoge@;` → `(hoge_p*)(arg) : Ret`

関数ポインタには関数のアドレスが入ってます。

## 文

関数定義には複文 (block satements) が続き、
その中には文 (statement) が並びます。

```
block = '{' stmt* '}'

stmt =
 | void     = ';'                     # 空文
 | block    = '{' stmt* '}'           # 複文
 | expr     = expr ';'                # 式文
 | var      = 'var' ident ?(':' type) ?('=' expr) ';' # ローカル変数定義
 | assign   = expr '=' expr ';'       # 代入文
# 制御文
 | if       = 'if' '(' expr ')' stmt
 | if_else  = 'if' '(' expr ')' stmt 'else' stmt
 | return   = 'return' ?( expr ) ';'
# 繰り返し文
 | while    = 'while' '(' expr ')' stmt
```

### 式文

式を評価します。評価値は破棄されるため、実用上は副作用を実行するための文です。

### 代入文

代入文が変数の値を書き換える唯一の方法です。

左辺はアドレス、右辺は値として評価できる必要があります。

`a : int = b : int`

という代入文は、実際には、

`a@ : *int <= b : int`

このような動作をしています。

## 式

### 演算

```
expr = or
or   = xor ('|' xor)*
xor  = and ('^' and)*
and  = eq ('&' eq)*
eq   = relat ('==' relat | '!=' relat)*
relat = shift ('<' shift | '<=' shift | '>' shift | '>=' shift)?
shift = add ('<<' add | '>>' add)?
add   = mul ('+' mul | '-' mul)*
mul   = cast ('*' cast | '/' cast | '%' cast)?
cast  = unary
```

### 単項演算子

```
unary =
 | post
 | pos    = '+' unary
 | neg    = '-' unary
 | not    = '!' unary
```

### 後置演算子

```
post =
 | prim
 | call   = post '(' expr % ',' ')'
 | index  = post '[' expr ']'
 | member = post '.' ident
 | deref  = post '*'
 | ref    = post '@'
```

## 値

```
prim =
 | number      # 数値リテラル
 | string      # 文字列リテラル
 | ident       # 識別子
 | '(' expr ')' # 括弧付き式
 | '{' (ident ':' expr) % ',' '}' # 構造体リテラル
 | '[' expr % ',' ']' # 配列リテラル
```

## アセンブリ

`asm` ブロック中では次の記述ができます。

```
asm_stmt =
 | label = ident ':'
 | inst  = ident ?('(' expr % ',' ')') ?( ';' )
```

### ラベル

`label:` の形式でラベルを定義します。

### 命令

`inst(arg1, arg2, ...)` の形式で命令を記述します。引数は式として評価されます。
